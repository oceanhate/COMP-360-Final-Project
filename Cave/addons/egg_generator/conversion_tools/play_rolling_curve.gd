@tool
extends Node
class_name PlayRollingCurve

## default position
@export var start_pos:Vector3 = Vector3.ZERO

## default rotation
@export var start_rotation:Vector3 = Vector3.ZERO

## axis around which it will rotate
@export var rotation_axis:Vector3 = Vector3.FORWARD

## up vector it will treat as height
@export var up_vector:Vector3 = Vector3.UP

## direction it will move while rotating
@export var movement_vector:Vector3 = Vector3.RIGHT

## node that will get rotated
@export var target:Node3D

## defined heights curve
## can be generated by the CreateRollingCurve node
@export var heights:Curve

## defined movement curve
## can be generated by the CreateRollingCurve node
@export var movement:Curve

# stores last angle
var last_angle:float = 0.0

## set the rotation and move the postion of target according to height and movement curve
func set_rotation(angle:float) -> void:
	if target == null:
		print("angle not set!")
		return
		
	if heights == null:
		print("height curve not set!")
		return
		
	if movement == null:
		print("movement curve not set!")
		return
		
	last_angle = angle
	
	# full range of movement for a full rotation
	var full_range:float = movement.sample(PI) - movement.sample(-PI)
	target.quaternion = Quaternion(rotation_axis, angle) * Quaternion.from_euler(start_rotation)
	
	var loops:float = floor((abs(angle) + PI) / TAU)
	var side_angle:float = fposmod(angle + PI, TAU) - PI
	var side_movement:float = movement.sample(side_angle)
	# if rotation exceeds one rotation, add the full range to side movement
	if loops > 0:
		side_movement += sign(angle) * full_range * loops
	
	var up_angle:float = fposmod(angle + PI, TAU) - PI
	var up_height:float = heights.sample(up_angle)
	target.position = start_pos + movement_vector * side_movement + up_vector * up_height
